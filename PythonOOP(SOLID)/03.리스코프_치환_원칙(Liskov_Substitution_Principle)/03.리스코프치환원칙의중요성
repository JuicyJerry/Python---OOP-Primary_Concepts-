"""리스코프 치환 원칙은 개발자끼리 작업할 때 중요하다.
이번 챕터에서 배운 리스코프 치환 원칙의 내용을 한번 정리해보겠습니다. 이 원칙의 정의는


"부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다" 입니다.


이 정의에 있는 내용대로 자식 클래스의 인스턴스가 부모 클래스의 인스턴스 대신 사용되어도 문제가 없으려면 2가지 조건을 만족해야 합니다.


첫번째는, 형식적인 측면에서 자식 클래스가 오버라이딩하는 변수와 메소드가 부모 클래스에 있는 형식과 일치해야 합니다. 변수의 경우에는 그 타입, 메소드의 경우에는 파라미터와 리턴값의 타입 및 개수가 그 형식입니다. 이런 형식적인 측면을 지키지 않으면 프로그램 실행 시에 에러가 발생하게 됩니다.


두번째는, 내용적인 측면에서 자식 클래스가 부모 클래스의 메소드에 담긴 의도, 그러니까 부모 클래스의 행동 규약을 위반하지 않는 겁니다. 이전 영상들에서 본


정사각형-직사각형 예시
음악 플레이어 예시

처럼 이 경우에는 프로그램을 실행해도 에러가 나지는 않습니다. 하지만 예상했던 결과와는 전혀 다른 결과를 프로그램이 내놓게 됩니다.


에러는 안 나는데 프로그램의 동작이 우리의 예상을 벗어난다는 것은 좀 무서운 일인데요. 예시로 봤던 코드들은 모두 내용이 짧았어서 이런 문제를 쉽게 발견했을 수도 있습니다. 하지만 만약 코드의 양이 많고 여러 객체 간의 관계가 복잡한 프로그램에서 이런 문제가 발생한다면 보이지 않는 치명적인 모순이 프로그램에 오랫동안 숨어있을 수 있습니다. 이런 일이 발생하지 않도록 하려면 자식 클래스를 설계할 때 부모 클래스의 행동 규약을 벗어나지 않도록 유의해야겠죠?


이전 영상에서 본 것처럼 리스코프 치환 원칙은 협업하는 개발자 사이의 신뢰를 위한 원칙이기도 합니다.


부모 클래스의 코드, 다양한 자식 클래스의 인스턴스들을 가져다 쓰는 코드를 작성하는 개발자 A와,
실제로 다양한 자식 클래스의 내용을 작성하는 개발자 B가 있다고 합시다.

개발자 A는 개발자 B가 리스코프 치환 원칙을 지키면서(부모 클래스의 행동 규약을 위반하지 않으면서) 자식 클래스를 작성할 것이라고 믿고, 코드를 짤 텐데요. 개발자 B가 이 믿음을 깨버린다면 나중에 최종 완성된 프로그램을 실행할 때


에러가 나거나,
에러가 나지는 않더라도 프로그램이 원래 의도와는 달리 비정상적으로 실행되는 현상

이 발생할 수 있겠죠? 그러니까 상속 관계를 적용할 때는 리스코프 치환 원칙을 늘 머릿속에 갖고 있어야 합니다.
"""
